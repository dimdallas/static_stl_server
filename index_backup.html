<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
		 <link rel="stylesheet" href="./style.css" /> 
		<title>MedicalAnimations_STL</title>
	</head>
	<body>
		<form name="uploadForm">
			<div>
				<input id="uploadInput" type="file" name="myFiles" multiple>
				<nav>
					<ul>
						<li>selected files: <span id="fileNum">0</span></li>
						<li>total size: <span id="fileSize">0</span></li>
					</ul>
				</nav>
			</div>
			<div><input type="submit" value="Send file"></div>
		</form>
		<script>
			function updateSize() {
				let nBytes = 0,
						oFiles = this.files,
						nFiles = oFiles.length;
				for (let nFileId = 0; nFileId < nFiles; nFileId++) {
					nBytes += oFiles[nFileId].size;
				}
				let sOutput = nBytes + " bytes";
				// optional code for multiples approximation
				const aMultiples = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
				for (nMultiple = 0, nApprox = nBytes / 1024; nApprox > 1; nApprox /= 1024, nMultiple++) {
					sOutput = nApprox.toFixed(3) + " " + aMultiples[nMultiple] + " (" + nBytes + " bytes)";
				}
				// end of optional code
				document.getElementById("fileNum").innerHTML = nFiles;
				document.getElementById("fileSize").innerHTML = sOutput;
			}

			document.getElementById("uploadInput").addEventListener("change", updateSize, false);
		</script>
		<script src="node_modules/jquery/dist/jquery.min.js"></script>
<!--		<input type="number" value="0" min="0" max="255" />-->
		<script type="module">

			import * as THREE from './three.module.js';
			import Stats from './stats.module.js';
			import { STLLoader } from './STLLoader.js';

			let container, stats;

			let camera, cameraTarget, scene, renderer;
			let rotationMeshFemur;
			let rotationMeshTibia;
			const rotationSpeed = .01;
			const zoomStep = .0005;
			var rotationBorder = 0;
			var step = 0;
			var zoom = 2;
			var rotation = .8;
			var prevPoint = 0;
			var fileList;

			let loader;
			var mesh_uuid;

			init();
			animate();

			function init() {

				// container = document.querySelector('.scene');
				container = document.createElement('div');
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 15 );
				camera.position.set( 3, 0.15, 3 );

				//vale target = module
				cameraTarget = new THREE.Vector3( 0, - 0.25, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x72645b );
				scene.fog = new THREE.Fog( scene.background, 2, 15 );
				
				// Ground
				const plane = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 40, 40 ),
					new THREE.MeshPhongMaterial( { color: 0x999999, specular: 0x101010 } )
				);
				plane.rotation.x = - Math.PI / 2;
				plane.position.y = - 0.5;
				plane.receiveShadow = true;
				scene.add( plane );


				// stats
				// stats = new Stats();
				// container.appendChild( stats.dom );
				//For Debugging
				const axesHelper = new THREE.AxesHelper();
				scene.add( axesHelper );
				let gridHelper = new THREE.GridHelper(5,5);
				//rotates in radians
				gridHelper.rotateX(1.55);
				scene.add(gridHelper);

				
				//CHOOSE FILE FROM FILE BROWSER
				// const selectedFile = document.getElementById('input').files[0];
				const inputElement = document.getElementById("uploadInput");
				inputElement.addEventListener("change", handleFiles, false);
				
				//DRAG AND DROP
				/*let dropbox;
				dropbox = document.getElementById("dropbox");
				dropbox.addEventListener("dragenter", dragenter, false);
				dropbox.addEventListener("dragover", dragover, false);
				dropbox.addEventListener("drop", drop, false);*/
				
				// ASCII file
				loader = new STLLoader();
				loader.load( './house/femur.stl', function ( geometry ) {

					//alert(geometry.attributes.position.count);
					const colors = [];

					for ( let i = 0, n = geometry.attributes.position.count; i < n; ++ i ) {

						colors.push( 1, 1, 1 );

					}

					geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
					const colors2 = geometry.attributes.color;
					var r,g,b;
					const strength = 10;
					const step = (strength / geometry.attributes.color.count);

					r = 1;
					g = 0;
					b = 0;

					for ( let i = 0, n = geometry.attributes.color.count; i < n; ++ i ) {
						
						if(r == 1)
						{
							r = 0;
							g = 1;
						}
						else if(g == 1)
						{
							g = 0;
							b = 1;
						}
						else if(b == 1)
						{
							b = 0;
							r = 1;
						}

						colors2.setXYZ( i, r,  g, b);

					}
					colors2.needsUpdate = true;
					
					//const material = new THREE.MeshPhongMaterial( { color: 0xfffffff	, specular: 0x111111, shininess: 100 } );	//0xfffffff				
					//const mesh = new THREE.Mesh( geometry, material );

					const material = new THREE.MeshLambertMaterial( {
					side: THREE.DoubleSide,
					color: 0xF5F5F5,
					vertexColors: true
					} );
					const mesh = new THREE.Mesh( geometry,  material);

					mesh.position.set( 0, 0, 0 );
					mesh.rotation.set(  -.5 * Math.PI, 0, 0 );
					mesh.scale.set( 0.005, 0.005, 0.005 );

					

					mesh.castShadow = true;
					mesh.receiveShadow = true;

					rotationMeshFemur = new THREE.Mesh( geometry, material );
					rotationMeshFemur = mesh;


					mesh_uuid = mesh.uuid;
					
					scene.add( mesh );
                });
                
                loader.load( './house/tibia.stl', function ( geometry ) {

					const material = new THREE.MeshPhongMaterial( { color: 0xfffffff, specular: 0x111111, shininess: 100 } );
					const mesh = new THREE.Mesh( geometry, material );

					mesh.position.set( 0, 0, 0 );
					mesh.rotation.set( - Math.PI / 2, 0 , 0 );
					mesh.scale.set( 0.005, 0.005, 0.005 );

					mesh.castShadow = true;
					mesh.receiveShadow = true;

					rotationMeshTibia = new THREE.Mesh( geometry, material );
					rotationMeshTibia = mesh;

					scene.add( mesh );

				} );



				// //Binary files

				// const material = new THREE.MeshPhongMaterial( { color: 0xAAAAAA, specular: 0x111111, shininess: 200 } );

				// loader.load( './models/stl/binary/pr2_head_pan.stl', function ( geometry ) {

				// 	const mesh = new THREE.Mesh( geometry, material );

				// 	mesh.position.set( 0, - 0.37, - 0.6 );
				// 	mesh.rotation.set( - Math.PI / 2, 0, 0 );
				// 	mesh.scale.set( 2, 2, 2 );

				// 	mesh.castShadow = true;
				// 	mesh.receiveShadow = true;

				// 	scene.add( mesh );

				// } );

				// loader.load( './models/stl/binary/pr2_head_tilt.stl', function ( geometry ) {

				// 	const mesh = new THREE.Mesh( geometry, material );

				// 	mesh.position.set( 0.136, - 0.37, - 0.6 );
				// 	mesh.rotation.set( - Math.PI / 2, 0.3, 0 );
				// 	mesh.scale.set( 2, 2, 2 );

				// 	mesh.castShadow = true;
				// 	mesh.receiveShadow = true;

				// 	scene.add( mesh );

				// } );

				// // Colored binary STL
				// loader.load( './models/stl/binary/colored.stl', function ( geometry ) {

				// 	let meshMaterial = material;

				// 	if ( geometry.hasColors ) {

				// 		meshMaterial = new THREE.MeshPhongMaterial( { opacity: geometry.alpha, vertexColors: true } );

				// 	}

				// 	const mesh = new THREE.Mesh( geometry, meshMaterial );

				// 	mesh.position.set( 0.5, 0.2, 0 );
				// 	mesh.rotation.set( - Math.PI / 2, Math.PI / 2, 0 );
				// 	mesh.scale.set( 0.3, 0.3, 0.3 );

				// 	mesh.castShadow = true;
				// 	mesh.receiveShadow = true;

				// 	scene.add( mesh );

				// } );


				// Lights

				scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

				addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
				addShadowedLight( 0.5, 1, - 1, 0xffaa00, 1 );
				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setPixelRatio( window.devicePixelRatio );				
				renderer.outputEncoding = THREE.sRGBEncoding;

				renderer.shadowMap.enabled = true;

				container.appendChild( renderer.domElement );
				
				window.addEventListener( 'resize', onWindowResize, true );
			}

			function handleFiles() {
				fileList = this.files; /* now you can work with the file list */
				console.log("hey")
				console.log(fileList[0].name)
				
				console.log(loader)
				console.log(scene)
				console.log(scene.getObjectById(mesh_uuid))
			}

			function dragenter(e) {
				e.stopPropagation();
				e.preventDefault();
			}

			function dragover(e) {
				e.stopPropagation();
				e.preventDefault();
			}

			function drop(e) {
				e.stopPropagation();
				e.preventDefault();

				const dt = e.dataTransfer;
				const files = dt.files;

				handleFiles(files);
			}

			function addShadowedLight( x, y, z, color, intensity ) {

				const directionalLight = new THREE.DirectionalLight( color, intensity );
				directionalLight.position.set( x, y, z );
				scene.add( directionalLight );

				directionalLight.castShadow = true;

				const d = 1;
				directionalLight.shadow.camera.left = - d;
				directionalLight.shadow.camera.right = d;
				directionalLight.shadow.camera.top = d;
				directionalLight.shadow.camera.bottom = - d;

				directionalLight.shadow.camera.near = 1;
				directionalLight.shadow.camera.far = 4;

				directionalLight.shadow.bias = - 0.002;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				// stats.update();

			}

			function render() {

				const timer = Date.now() * 0.0002;

				$(window).on("wheel", function(e) {
					if (e.originalEvent.deltaY < 0) 
					{
						zoom += zoomStep;
					}
					else
					{
						zoom -= zoomStep;
					}				
				});

				$(window).on("mousedown",function() {
					$(window).mousemove(function( event ) {
						var offset = event.pageX - prevPoint;
						if(offset > 0)
						{														
							rotation += rotationSpeed;
						}
						else if(offset < 0)
						{
							rotation -= rotationSpeed;														
						}					
						prevPoint = event.pageX;
					});																					
				});

				$(window).on("mouseup",function() {
					$(window).off("mousedown");
					$(window).off("mousemove");															
				});
				

				if(rotationBorder <= 0)
				{
					 step = .01;
				}
				else if(rotationBorder > 5)
				{
					 step = -.01;
				}
				rotationBorder = rotationBorder + step;
				camera.position.x = Math.cos( Math.PI * rotation) * zoom;
				camera.position.z = Math.sin( Math.PI * rotation) * zoom;
				rotationMeshFemur.rotation.set( -0.1  * Math.PI * rotationBorder, 0,0 );
				
				//correct tibia rotation error
				
				camera.lookAt( cameraTarget );

				renderer.render( scene, camera );

			}
		</script>
	</body>
</html>